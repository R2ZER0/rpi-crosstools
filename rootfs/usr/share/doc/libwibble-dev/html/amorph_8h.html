<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>wibble: amorph.h File Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">wibble
   &#160;<span id="projectnumber">0.1.28</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">amorph.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;iostream&gt;</code><br/>
<code>#include &lt;<a class="el" href="mixin_8h_source.html">wibble/mixin.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="cast_8h_source.html">wibble/cast.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="maybe_8h_source.html">wibble/maybe.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="sfinae_8h_source.html">wibble/sfinae.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="test_8h_source.html">wibble/test.h</a>&gt;</code><br/>
</div><div class="textblock"><div class="dynheader">
Include dependency graph for amorph.h:</div>
<div class="dyncontent">
<div class="center"><img src="amorph_8h__incl.png" border="0" usemap="#amorph_8h" alt=""/></div>
<map name="amorph_8h" id="amorph_8h">
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="amorph_8h__dep__incl.png" border="0" usemap="#amorph_8hdep" alt=""/></div>
<map name="amorph_8hdep" id="amorph_8hdep">
</map>
</div>
</div>
<p><a href="amorph_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwibble_1_1ReturnType.html">wibble::ReturnType&lt; _T &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwibble_1_1ReturnType_3_01void_01_4.html">wibble::ReturnType&lt; void &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwibble_1_1SanitizeReturn.html">wibble::SanitizeReturn&lt; F, R &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwibble_1_1SanitizeReturn_3_01F_00_01void_01_4.html">wibble::SanitizeReturn&lt; F, void &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwibble_1_1IsZero.html">wibble::IsZero&lt; A &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwibble_1_1IsZero_3_010_01_4.html">wibble::IsZero&lt; 0 &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwibble_1_1IsPolymorphic.html">wibble::IsPolymorphic&lt; T &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwibble_1_1IsPolymorphic_1_1A.html">wibble::IsPolymorphic&lt; T &gt;::A</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwibble_1_1IsPolymorphic_1_1B.html">wibble::IsPolymorphic&lt; T &gt;::B</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwibble_1_1SanitizeResultType.html">wibble::SanitizeResultType&lt; F &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwibble_1_1Baseless.html">wibble::Baseless</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwibble_1_1VirtualBase.html">wibble::VirtualBase</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwibble_1_1MorphInterface.html">wibble::MorphInterface&lt; Interface &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An interface implemented by all morph classes.  <a href="structwibble_1_1MorphInterface.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwibble_1_1MorphAllocator.html">wibble::MorphAllocator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">custom allocator for morph classes  <a href="structwibble_1_1MorphAllocator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwibble_1_1MorphBase.html">wibble::MorphBase&lt; W, Interface &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwibble_1_1Morph.html">wibble::Morph&lt; Self, W, Interface &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwibble_1_1AmorphPadder.html">wibble::AmorphPadder&lt; Padding1 &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwibble_1_1AmorphPadder_3_010_01_4.html">wibble::AmorphPadder&lt; 0 &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwibble_1_1Amorph.html">wibble::Amorph&lt; Self, _Interface, Padding &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwibble_1_1Amorph_1_1Convert.html">wibble::Amorph&lt; Self, _Interface, Padding &gt;::Convert&lt; T &gt;</a></td></tr>
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewibble.html">wibble</a></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="amorph_8h.html#a2b23b4a5a1866d1ce98fec651cadd0d5">WIBBLE_AMORPH_H</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="amorph_8h.html#a84ecd38be2fec6c72bee552af9b7e598">WIBBLE_AMORPH_PADDING</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Amorph base class.  <a href="#a84ecd38be2fec6c72bee552af9b7e598"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename X &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">X::template Convert&lt; T &gt;::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewibble.html#a57fc3989a0b350bef554147bfb69e122">wibble::downcast</a> (const X &amp;a)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>-*- C++ -*-</p>
<dl class="author"><dt><b>Author:</b></dt><dd>Peter Rockai &lt;<a href="mailto:me@mornfall.net">me@mornfall.net</a>&gt; </dd></dl>
</div><hr/><h2>Define Documentation</h2>
<a class="anchor" id="a2b23b4a5a1866d1ce98fec651cadd0d5"></a><!-- doxytag: member="amorph.h::WIBBLE_AMORPH_H" ref="a2b23b4a5a1866d1ce98fec651cadd0d5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="amorph_8h.html#a2b23b4a5a1866d1ce98fec651cadd0d5">WIBBLE_AMORPH_H</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a84ecd38be2fec6c72bee552af9b7e598"></a><!-- doxytag: member="amorph.h::WIBBLE_AMORPH_PADDING" ref="a84ecd38be2fec6c72bee552af9b7e598" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="amorph_8h.html#a84ecd38be2fec6c72bee552af9b7e598">WIBBLE_AMORPH_PADDING</a>&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Amorph base class. </p>
<p>This class is an Amorph class. An Amorph can hold one of many Morhps of the corresponding kind. That means, Amorph is an envelope that can contain an instance of a Morph. The Amorph envelope can provide methods that all the Morphs that it can hold provide as well. These methods will then act polymoprhically in the Amorph instance, depending on what Morph is inside.</p>
<p>You use the Amorph and Morph classes as values, that is, they have value semantics. You usually do not need (nor want) to use pointers to access them. Of course it may be useful sometimes, but is not the normal mode of operation.</p>
<p>Amorph objects are equal if they hold same type of Morph and the Morphs themselves are also equal. Different types of Morphs are never equal.</p>
<p>When implementing your own Amorph class, you will want it to contain the methods that are shared by all it's Morphs. These will usually look like</p>
<p>methodFoo() { return this-&gt;impl()-&gt;methodFoo(); }</p>
<p>If you need to dispatch on the type of the Morph inside the Amorph envelope, you can use</p>
<p>if ( amorph.is&lt; MyMorph &gt;() ) { MyMorph morph = amorph; }</p>
<p>or if you write adaptable unary function objects (see stl manual) handling the specific morph types, you can write:</p>
<p>amorph.ifType( functor );</p>
<p>This will call functor on the morph type if the functor's argument_type matches the type of contained Morph. The returned type is Maybe&lt; functor::result_type &gt;. If the type matches, the returned value is Just (returned value), otherwise Nothing.</p>
<p>See <a class="el" href="structwibble_1_1Maybe.html">wibble::Maybe</a> documentation for details.</p>
<p>This also lends itself to template specialisation approach, where you have a template that handles all Morphs but you need to specialize it for certain Morphs. Eventually, an example of this usage will appear in amorph.cpp over time.</p>
<p>Often, using Amorph types will save you a template parameter you cannot afford. It also supports value-based programming, which means you need to worry about pointers a lot less.</p>
<p>For a complex example of Amorph class set implementation, see <a class="el" href="range_8h.html">range.h</a>.</p>
<p>Implementation details: the current Amorph template takes an integral Padding argument. The MorphImpl class contains an overloaded operator new, that allows it to be constructed off-heap. The Padding argument is used as a number of words to reserve inside the Amorph object itself. If the Morph that will be enveloped in the Amorph fits in this space, it will be allocated there, otherwise on heap. The Padding size defaults to 0 and therefore all Morphs are by default heap-allocated. Reserving a reasonable amount of padding should improve performance a fair bit in some applications (and is worthless in others). </p>

</div>
</div>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Wed May 2 2012 23:57:29 for wibble by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
